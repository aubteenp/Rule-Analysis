---
title: "FDA Rule Analysis Quarto"
format: html
editor: visual
---

## Intro

In the summer of 2024, the Supreme Court issued two landmark rulings -- *Ohio v. EPA* on June 27, 2024, and *Loper Bright Enterprises v. Raimondo* on June 28, 2024 -- that transformed the regulatory landscape for federal agencies. In *Ohio v. EPA*, the Court held that an agency's failure to adequately respond to significant public comments during the notice-and-comment process renders its rules arbitrary and capricious. The following day, in *Loper Bright v. Raimondo*, the Courtoverruled Chevron deference, directing lower courts to interpret statutory ambiguities independently rather than deferring to agency interpretations. In doing so, the Court substantially reduced agency latitude in interpreting legislative "gray areas".

We hypothesize that these decision created an environment where agencies are less likely to publish formal rules. The increased logistical burden of addressing public comments post-*Ohio v. EPA* and the heightened risk of litigation over statutory interpretations post-*Loper Bright* likely discourage rulemaking. To investigate this hypothesis, we employ quantitative methods---specifically, regression-discontinuity and interrupted time series analyses---using the period following the release of Loper Bright Enterprises v. Raimondo (starting June 29, 2024) as a cutoff. This study aims to empirically assess how these Supreme Court rulings have impacted agency rulemaking behavior.

## Running Code

```{r}
#| label: Read in csv files
#| echo: false
#| warning: false

library(dplyr)

#read csv
#df <- read.csv("All CMS Rules from 1_14_2025.csv", stringsAsFactors = FALSE)
df <- read.csv("All FDA Rules 1_14_2025 to 1_4_1994.csv", stringsAsFactors = FALSE)
#df <- read.csv("DHHS Pull - 12_1_2023 to 1_19_2025.csv", stringsAsFactors = FALSE)
#df <- read.csv("ALL RULES 11_13_2023_to_01_19_2025.csv", stringsAsFactors = FALSE)

# 2. Convert 'publication_date' to Date format
df <- df |>
  mutate(publication_date = as.Date(publication_date, format = "%m/%d/%Y"), 
         year = format(publication_date, "%Y"),
         month = format(publication_date, "%B")
         )

# View the first few rows to verify
#df

```

Now, create plots from df data frame

```{r}
#| label: Grouping Rules by Year and display
#| echo: false
#| warning: false


library(ggplot2)
library(lubridate)
library(dplyr)
library(tidyr)


#generates table with number of rules per year
rules_per_year <- df |>
  group_by(year) |>
  summarize(count = n()) |>
  arrange(year)


#plot 1 - number of rules per year
ggplot(rules_per_year, 
       aes(x = as.numeric(year), 
           y = count)) +
  geom_line(color = "steelblue", size = 1) +
  geom_point(color = "darkred", size = 2) +
  labs(
    title = "Number of Rules Published Each Year",
    x = "Year",
    y = "Number of Rules"
  ) +
  theme_minimal()

```

Next, let's analyze the data broken into its constituent months (the first visualization doesn't work yet)

```{r}
#| label: Grouping Rules by month Data
#| echo: false


# #class(df$year)
# # Convert the 'year' var into a numeric value (important for years_seq)
# 
# df <- df %>%
#   mutate(year = as.numeric(as.character(year)))
# 
# # Define the complete sequence of years from the minimum to the maximum year in the dataset
# years_seq <- seq(min(df$year), max(df$year), by = 1)

# 1. Summarize data by year and month
rules_summary <- df %>%
  group_by(year, month) %>%
  summarise(count = n(), .groups = 'drop')

# 2. Determine the date range from existing publication_date values
min_date <- min(df$publication_date, na.rm = TRUE)
max_date <- max(df$publication_date, na.rm = TRUE)

# 3. Create a continuous sequence of dates at the start of each month within the actual range
all_months <- tibble(date = seq.Date(from = floor_date(min_date, "month"),
                                     to   = floor_date(max_date, "month"),
                                     by   = "month")) %>%
  mutate(year  = format(date, "%Y"),
         month = format(date, "%B"))

# 4. Join the full monthly sequence with summarized data and fill missing counts with 0
rules_per_month_year <- all_months %>%
  left_join(rules_summary, by = c("year", "month")) %>%
  mutate(count = replace_na(count, 0)) %>%
  arrange(date)

# rules_per_month_year <- df |>
#   group_by(year, month) |>
#   summarise(count = n(), .groups = 'drop') |>
#     # Convert 'month' to an ordered factor to ensure correct ordering
#   mutate(month = factor(month, levels = month.name, ordered = TRUE)) |>
#   # Use 'complete()' to fill in missing year-month combinations
#   complete(year = years_seq, month = month.name, fill = list(count = 0)) |>
#   arrange(year, match(month, month.name))  # Ensure correct month order
```

```{r}
#| label: Visualization of Grouping Rules by month and display
#| echo: false


#plot 2 - number of rules published each month within each year


ggplot(rules_per_month_year, aes(x = month, y = count, group = 1)) +
  geom_line(color = "darkgreen", size = 1) +
  geom_point(color = "orange", size = 2) +
  labs(
    title = "Number of Rules Published Each Month Within Each Year",
    x = "Month",
    y = "Number of Rules"
  ) +
  theme_minimal() +
  facet_wrap(~ year, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

#Monthly Number of Rules Published Over Time
ggplot(rules_per_month_year, aes(x = as.Date(paste(year, month, "01", sep = "-"), format = "%Y-%B-%d"), y = count)) +
  geom_line(color = "steelblue") +
  labs(title = "Monthly Number of Rules Published Over Time",
       x = "Date",
       y = "Number of Rules") +
  theme_minimal()
```

The following graph depicts the data broken into consituent months and highlights Presidential transition years.

```{r}
#| label: Cleaning Data for Model
#| echo: false

#creates data frame with number of rules published in each month of each year
monthly_counts <- df %>%
  group_by(year, month) %>%
  summarise(count = n()) %>%
  ungroup()

#Create seasonal tags
df <- df |>
  mutate(
    quarter = quarter(publication_date)
  )

# Define presidential transition years, and create transition indicator
transition_years <- c(2000, 2008, 2016, 2020, 2024)

df <- df %>%
  mutate(
    transition = ifelse(year %in% transition_years, 1, 0)
  )

monthly_counts <- monthly_counts %>%
  mutate(
    transition = ifelse(year %in% transition_years, 1, 0)
  ) |>
    arrange(year, month) %>% 
  # Create a marker when transition status changes compared to the previous row
  # Without this marker, red lines would connect months in adjacent transition years
  mutate(change = transition != lag(transition, default = first(transition))) %>%
  # Assign a unique group ID for each consecutive segment of identical transition status
  mutate(group = cumsum(change))


ggplot(monthly_counts, aes(x = as.Date(paste(year, month, "01", sep = "-"), format = "%Y-%B-%d"), y = count, color = factor(transition),
                           group = group)) +
  geom_line() +
  labs(title = "Monthly Number of Rules Published with Transition Years Highlighted",
       x = "Date",
       y = "Number of Rules",
       color = "Transition Year") +
  scale_color_manual(values = c("0" = "grey", "1" = "red")) +
  theme_minimal()

```

## Regression Discontinuity Analysis

$$
Y_i = \alpha + \tau D_i + \beta X_i + \gamma X_i^2 + \sum_{m=1}^{11} \delta_m M_{im} + \theta T_i + \epsilon_i
$$

Where:

-   ($Y_i$): Number of Rules Published in month ($i$).

-   ($\alpha$): Intercept term (baseline level of ($Y$).

-   ($D_i$): Treatment Indicator for month ($i$). $D_i$ = 1 if month $i$ is after June 2024 and 0 otherwise.

-   ($X_i$): Running Variable representing the distance from the cutoff (June 2024) for month $i$). Measured in months: $X_i$ = Number of months since June 2024

    -   ($X_i > 0$): Post-June 2024 (treatment group)

    -   ($X_i < 0$): Pre-June 2024 (control group)

-   ($\beta$): The Treatment Effect

-   ($X_i^2$): Quadratic Term to capture potential non-linear trends in the data.

-   ($M_{im}$): Monthly Dummy Variables for each month ( $m$, January to December), excluding one month to avoid multicollinearity (January is the reference category).

-   ($\delta_m$): Coefficients for each monthly dummy variable, capturing the effect of being in month ($m$) relative to the reference month.

-   ($T_i$): Presidential Transition Indicator for month ($T_i$): $T_i$ =1 for 2008, 2016, 2020, or 2024 and 0 otherwise.

-   ($\theta$): Coefficient capturing the effect associated with presidential transition years.

-   ($\epsilon_i$): Error Term capturing unobserved factors affecting ($Y_i$).

```{r}
#| label: RD Model
#| echo: false

library(dplyr)
library(lubridate)

# Define cutoff date (June 2024)
cutoff_date <- ymd("2024-06-29")

# Create running variable (distance from cutoff in months)
rules_per_month_year <- rules_per_month_year |>
  mutate(
    publication_date = make_date(year, match(month, month.name), 1),  # First day of the month
    distance = interval(ymd("2001-01-01"), publication_date) / months(1) - 
      (interval(ymd("2001-01-01"), cutoff_date) / months(1)),
    treatment = ifelse(publication_date > cutoff_date, 1, 0)
  )

# Convert month to factor with correct ordering
rules_per_month_year <- rules_per_month_year %>%
  mutate(
    month = factor(month, levels = month.name, ordered = TRUE),
    transition = ifelse(year %in% c(2008, 2016, 2020, 2024), 1, 0)
  )

# Create monthly dummies (excluding January to avoid multicollinearity)
rules_per_month_year <- rules_per_month_year %>%
  mutate(
    month_dummy = factor(month, levels = month.name)
  )

# Fit the RD model using linear regression
rd_model <- lm(count ~ treatment + distance + I(distance^2) + 
                month + transition, data = rules_per_month_year)

# View the summary of the model
summary(rd_model)
```

Now, let's visualize the RD regression, displaying the number of rules published in the 7 months before and after the cutoff date

```{r}
#| label: RD Visualization
#| echo: false

# Define cutoff date
cutoff_date <- as.Date("2024-06-29")

# Filter data to include 7 months before and after the cutoff
plot_data <- rules_per_month_year %>%
  filter(publication_date >= cutoff_date %m-% months(7) &
         publication_date <= cutoff_date %m+% months(6))

# Add a column to indicate the side of the cutoff for coloring (optional)
plot_data <- plot_data %>%
  mutate(side = ifelse(publication_date < cutoff_date, "Pre", "Post"))

ggplot(plot_data, aes(x = publication_date, y = count)) +
  geom_point(aes(color = side), size = 2) + 
  # Add vertical line to mark the discontinuity
  geom_vline(xintercept = as.numeric(cutoff_date), linetype = "dashed", color = "red", size = 1) +
  # Add separate linear regression lines for pre- and post-cutoff periods
  geom_smooth(data = filter(plot_data, publication_date < cutoff_date), 
              method = "lm", se = FALSE, color = "blue", size = 1) +
  geom_smooth(data = filter(plot_data, publication_date >= cutoff_date), 
              method = "lm", se = FALSE, color = "darkgreen", size = 1) +
  labs(
    title = "Monthly Rule Count Around June 29, 2024",
    subtitle = "Displaying 7 months before and after the cutoff",
    x = "Publication Date",
    y = "Number of Rules",
    color = "Period"
  ) +
  scale_color_manual(values = c("Pre" = "orange", "Post" = "purple")) +
  theme_minimal()
```

Now we'll try an ITS model.

```{r}
#| label: ITS Model
#| echo: false

#install.packages("forecast")
library(forecast)
library(dplyr)
library(lubridate)
# The following variables have already been created:
# - publication_date: Date object representing the first day of each month
# - distance: Numeric (months since cutoff; negative before, positive after)
# - treatment: Binary (1 if post-June 2024, 0 otherwise)
# - month: Ordered factor (January to December)
# - transition: Binary (1 if year is 2008, 2016, 2020, 2024; 0 otherwise)
# - month_dummy: Factor (monthly dummy variables)

# Step 1: Calculate 'Time' and 'TimeAfterIntervention'

min_date <- min(rules_per_month_year$publication_date, na.rm = TRUE)

# Define the start year and month for the time series
start_year <- year(min_date)
start_month <- month(min_date)

rules_per_month_year <- rules_per_month_year |>
  arrange(publication_date) |>  # Ensure data is sorted by date
  mutate(
    Time = ((year(publication_date)) - start_year) * 12 + 
           (month(publication_date) - start_month) + 1,  # +1 to start at 1
    TimeAfterIntervention = ifelse(treatment == 1, Time - min(Time[treatment == 1]) + 1, 0)  # Time since intervention
  )

#Define most recent data
max_date <- max(rules_per_month_year$publication_date, na.rm = TRUE)

# Define the start year and month for the time series
end_year <- year(max_date)
end_month <- month(max_date)
# Convert 'count' to a time series object
ts_rules <- ts(rules_per_month_year$count, start = c(start_year, start_month), c(end_year, end_month), frequency = 12)

ts_rules

# Define external regressors
external_regressors <- cbind(
  Intervention = rules_per_month_year$treatment,
  TimeAfterIntervention = rules_per_month_year$TimeAfterIntervention
)

# Fit the ARIMA model with external regressors
its_model <- auto.arima(ts_rules, xreg = external_regressors, seasonal = TRUE)

# Display the summary
summary(its_model)

```

```{r}
#| label: Read in Guidance Data
#| echo: false

library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)

guidance_df <- read.csv("All FDA Guidance Documents.csv", skip = 1, stringsAsFactors = FALSE)

# Convert 'Issue Date' to Date format and extract year and month
guidance_df <- guidance_df %>%
  mutate(
    publication_date = as.Date(`Issue.Date`, format = "%m/%d/%Y"),
    year = format(publication_date, "%Y"),
    month = format(publication_date, "%B")
  )

# Filter to include only Final Guidance Documents
guidance_final_df <- guidance_df %>%
  filter(`Guidance.Status` == "Final")

# Verify the filtering
#table(guidance_final_df$`Guidance Status`)

```

```{r}
#| label: Aggregating FDA Rules and Final Guidance Counts by Month
#| echo: false

# Aggregate counts of Rules per month (existing data)
rules_monthly_counts <- rules_per_month_year %>%
  select(year, month, count) %>%
  rename(rules = count)

# Aggregate counts of Final Guidance Documents per month
guidance_monthly_counts <- guidance_final_df %>%
  group_by(year, month) %>%
  summarise(guidance = n(), .groups = 'drop')

# Combine Rules and Guidance counts
combined_counts <- full_join(rules_monthly_counts, guidance_monthly_counts, by = c("year", "month"))

# Replace NA with 0 for months with no Rules or Guidance
combined_counts <- combined_counts %>%
  replace_na(list(rules = 0, guidance = 0))

# Ensure the 'year' column is numeric
combined_counts <- combined_counts %>%
  mutate(year = as.numeric(year))

# Filter for years 1996 and later
combined_counts <- combined_counts %>%
  filter(year >= 1996)

# View the combined counts
head(combined_counts)


```

```{r}
#| label: sort combined_counts in descending order by date
#| echo: false

# Create a 'date' column representing the first day of each month
combined_counts <- combined_counts %>%
  mutate(
    date = make_date(year = as.numeric(year), month = match(month, month.name), day = 1)
  )

# Sort the dataframe by 'date' in descending order
combined_counts_sorted_desc <- combined_counts %>%
  arrange(desc(date))

# Display the first few rows to verify
head(combined_counts_sorted_desc)


```

```{r}
#| label: calculate rule-to-guidance proportion
#| echo: false

# Calculate the proportion of rules to total documents
combined_counts <- combined_counts %>%
  mutate(
    total_documents = rules + guidance,
    proportion_rules = ifelse(total_documents > 0, rules / total_documents, NA)
  )

```

```{r}
#| label: plot proportion over time
#| echo: false

library(ggplot2)

ggplot(combined_counts, aes(x = date, y = proportion_rules)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "darkblue", size = 2) +
  geom_vline(xintercept = as.numeric(as.Date("2024-06-29")), 
             linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = as.Date("2024-06-29"), 
           y = max(combined_counts$proportion_rules, na.rm = TRUE), 
           label = "Cutoff Date", vjust = -1, hjust = 1.1, color = "red") +
  labs(
    title = "Proportion of FDA Rules to Total Documents Over Time",
    subtitle = "With Cutoff Date Highlighted",
    x = "Publication Date",
    y = "Proportion of Rules"
  ) +
  theme_minimal()

```

```{r}
#| label: plot proportion per year over time
#| echo: false
library(scales)  
combined_counts_yearly <- combined_counts %>%
  mutate(year = as.numeric(year)) %>%  # Ensure 'year' is numeric
  group_by(year) %>%
  summarise(
    total_rules = sum(rules, na.rm = TRUE),
    total_guidance = sum(guidance, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    proportion_rules = ifelse(
      (total_rules + total_guidance) > 0,
      total_rules / (total_rules + total_guidance),
      NA
    )
  )


# Create the line plot
ggplot(combined_counts_yearly, aes(x = year, y = proportion_rules)) +
  geom_line(color = "steelblue", size = 1) +
  geom_point(color = "darkblue", size = 2) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Annual Proportion of FDA Rules to Final Guidance Documents",
    subtitle = "Trend from 1996 to 2025",
    x = "Year",
    y = "Proportion of FDA Rules",
    caption = "Source: FDA Rules and Guidance Documents Data"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )

```

```{r}
#| label: Prep Data for RD Model
#| echo: false

# Define cutoff date (June 29, 2024)
cutoff_date_rd <- as.Date("2024-06-29")

# Prepare the data for RD analysis
rd_data_proportion <- combined_counts %>%
  mutate(
    # Ensure 'date' is correctly formatted
    publication_date = date,
    
    # Calculate distance in months from cutoff
    distance = interval(ymd("2001-01-01"), publication_date) / months(1) - 
               interval(ymd("2001-01-01"), cutoff_date_rd) / months(1),
    
    # Treatment indicator: 1 if post-cutoff, 0 otherwise
    treatment = ifelse(publication_date > cutoff_date_rd, 1, 0)
  ) %>%
  # Create presidential transition indicator
  mutate(
    transition = ifelse(year(publication_date) %in% c(2000, 2008, 2016, 2020, 2024), 1, 0)
  ) %>%
  # Convert 'month' to an ordered factor
  mutate(
    month = factor(month, levels = month.name, ordered = TRUE)
  )
```

```{r}
#| label: Fitting  RD Model for prop of FDA Rules to guidance
#| echo: false



# Fit the RD model using linear regression
rd_model_proportion <- lm(proportion_rules ~ treatment + distance + I(distance^2) + 
                            month + transition, data = rd_data_proportion)

# View the summary of the RD model
summary(rd_model_proportion)

```

```{r}
#| label: ITS Model for Prop
#| echo: false

library(forecast)     # For ARIMA modeling


# Define the intervention date
intervention_date <- as.Date("2024-06-29")

# Create time variables
combined_counts <- combined_counts %>%
  arrange(date) %>%  # Ensure data is sorted by date
  mutate(
    # Time since start (in months)
    time = as.numeric(difftime(date, min(date), units = "weeks")) / 4.345,  # Approximate months
    
    # Binary indicator for intervention (1 = post-intervention, 0 = pre-intervention)
    intervention = ifelse(date >= intervention_date, 1, 0),
    
    # Time after intervention (0 before intervention)
    time_after = ifelse(date >= intervention_date, time - min(time[intervention == 1]), 0)
  )

# Fit the segmented regression model
its_model <- lm(proportion_rules ~ time + intervention + time_after, data = combined_counts)

# View the summary of the model
summary(its_model)


```
